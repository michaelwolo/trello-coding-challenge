var string = "hpevfwqjmjryhemuqjoiatpjmddxdjwzskdcfgdtbmkbcxrnmjuoyddnqwluimjwvguxehszxzvbmufqlrepncxxbrrzxnzmkoyhrjcstvfazyhrhgssximjdfcmdjusylfkwbedyrsxovrmvjzaljfjmywpfnjgisoqbdyspgzlcmdjmhbpxhzvvhckidzuwzkauffsujmcrhvgeqvasjakgtzlxkthjqwxypmsovjbfshrrxtdvkmbyhejoeydnrdowuwhgmbvxmpixyttglsjgmcoqbberssfjraaqfrkmebsozsjfnubhktbbai_vxbifbofyednnutmxtisvfsktbqfijfzdjoqybuohtztysqelaqyixyaiolbgwylwfisfwubivuoablxsmrqggedwyiqvseevwbcxcfjttdbweedcjgnsorizflsjtmltcoaynsrsupavqwcyzhgiplwkohlhrainazaacvuqblpbzimgoxirejbshnbmdtgsbvlhpnugggencjaczqqiwixrwiyobmlkbwdlwcioqmjhoacdvcqdypxeichmgywocbcafumthdqrbjnpgnnmaasxiaxxfymcyiuqduztqneodstbcnjpeebgxgosoydvpzlqjuroebbehafsemanwprhwkircuhlgcftqsjdusrqetbthxclfokpdlspxzuvhxpbeqqbfpqffsgyilqltfxrmtimcugytazkerhcfnirtavcnmfdyictlncwttkmxyfhgejygfefqrjknuqsfldmjmwjdfqsicfrzbfazchdgznekwmhridelcejnkmcgmpgtihbwmplrtrrefoyhyzxpjjlkabbbgspeokzhpjxsvpfjmdsoripvfrgyzxodoeirwwdaofdmwqrqyvdijlfqyzfspdoyrhewxbpufdqcpqdolkmrnvedixzpfdakggkslxcrjbrmnynviihbkzaqqffkkcgwjbettexhlwlasdfjnslwsmnclhafvebxxfdozsjtdvobikrrsuysujwliobagobxmlyxjeltwzwxpyrnkdxfemotfncyriaycyfemygjmpboocgtsvttqntegvleynwgpjhyyysbltoxljsascsngbgfqmpzgpejzlmdkjzzlfxvagyrasmpzqntgqsvyqjugkhbrbkiqewlyftvsq_______znp_____xkwt______wef______tz______kfc_______ha_______pn__lmg__iakrbtiyfi__uojrxvx__tps__fp__pfpndbi__ggpalde__wmd__kn__ifiadob__hdljdbd__zl__whlwiltbcmt__haagmjg__dwx__oh__utnzudq__xstxxyc__vly__mr__viilzav__swosyvc__i__hnaqxyevjykc__wyfoyir__ewp__ij__mrdavxl__tcdtxqy__fnr__cf__mrkepwj__djhrsau____lhefqxgmuzdgf______tjg__fip__mi__b____xc__vjvhpqy______vff_____wuup_____kqct___htiggvvpetyvco__pqbrlox__ayj__af__dnn__kx__mlitytx____jauna__kncmiym__dlwushk____gjptzccgcnntt__hfqyxzi__eqn__vz__hlh__we__dtfkfvf__g__litm__zeqjtdl__bkdapxs__o__oxeouwerbfjr__ipcqmop__kec__ip__icc__ci__vpxxueu__eq__sau__nhheydy__efqkdgq__us__pzlndhkhdmk__cmfvzwcb_____xdka______trj______yj__xpi__he_______nb_______by__rrn__tvxvigjfpseyjjbrrtsfnmbrokdqtfzhhdtbhtvpiyshmvcqaypfxcvbgvbvwrkanjfcsjnanmktkwimnvynukcmgtqmovkrdmfuduqvbqydagsttictcnsrhfrpoebcehdzhjamykqpjtktufcvokljjijjsrivyhxtgwojgoujyhmekzsoczwlqnruwcuhudgfaijzrkewzgjvorsmabpcdmurctwjrddcnkmfvabjwlbqssihdybgfqchqdvjcsdllrlwmyikuvthguzfbgocaeqktvbcapzdcfjphqnhundtljqjeyfrkjspfvghqddxwxidtjjkctrkfcjmdpqyvavqbntpmkkuswfgbgalrysjfnzezjjscahoodjjelavydefzjmhsqfufsexlvvzziymsyqrcvhsrxjnysioswvjlqdbnwgyjlanmhzkbygkptycdoifsibytbrixggjeiepaybzxhvfsyayeptgpxbhhfkkpromhjykfxnujorlzcmkcmvvgmveyfkgiwgosznfpmbhixsakxfkuxhwcgularehpaguquulrjllxmkfzgnchrxzcfdklytpfnezergkwkhgalqlvdhkdgulgfaxtybqttcjtlgmfwaymaxlwaspyrboibwkzzbtgigyswbtpwxgphcmkfpmvbfjimnxctinqssshofhlvlpqcwiuacjyxyqmvaibezofvatyhpqvjubgcwqeoytloypjphoxeimumuvswxkgamodoxiciwmgxvsenkgdhttzlenjbszrksopicjcjnvsosrapkfilwsaoptdavlfglioqpwoqskbgikksnnuzvmxyrtrbjouvgokxgbnwxnivtykvhjkaydskzoowbhjrlojgeecdoggqqtomcdgrjzmlkhubyaewwtrlyutsptdrrigopueicoganyasrjeaiivzairulklovyrpckwpowprxtvhaeivpudfchxbwvtosmivpcsesbzpsynxitlisuifuehceonjeydljzuzpsgjllcywoxbblitscquxiykcjxhsgkbhfhfrshsrpyrcaetahuwbeybvlvkthxydkapxlfikdwudjkmjjsazajxpuikiqwsifhldfovqoycwmtlmcaycirhcehxnpfadrgyaogpcmomcgtmacnvbwfnimaqqvxijcbpmckwimloiinindfuakqjmpyjisxnbybtywhymnkdoyiphijzelmrazplgfcmcsjiovxqdxmuqulzklgx";

// function Parser(string) {

// 	var pairsPresent = this.check(this.storeMultiples())
// 	  , largest = {};
// 	console.time('Parsed in');
// 	while (pairsPresent) {
// 		largest = this.getFirstValid(this.createSorted(this.storeMultiples()));
// 		string = this.change(largest);
// 		console.log(string);
// 		pairsPresent = this.check(this.storeMultiples());
// 	}
// 	string = this.strip(string);
// 	console.timeEnd('Parsed in');
// 	console.log(string);

// }

// Parser.prototype = {

// 	// Return an object of characters as properties and their index values as array values
// 	// Example: For string, 'hello', return object {'h': [0], 'e': [1], 'l': [2,3], 'o': [4]}
// 	storeMultiples: function () {
// 		var str = string
// 		  , hash = {};
// 		for (i = 0; i < str.length; i++) {
// 			if (hash[str[i]]) {
// 				hash[str[i]].push(i);
// 			} else {
// 				hash[str[i]] = [i];
// 			}
// 		}
// 		return hash;
// 	},

// 	// Return true for the first property value array that contains multiple values
// 	check: function (obj) {
// 		for (i in obj) {
// 			if (obj[i].length > 1) {
// 				return true;
// 			}
// 		}
// 	},

// 	// Return string after removing the character pair and adding a copy of the character to the end
// 	change: function (obj) {
// 		var str = string
// 		  , letter = str[obj.b];
// 		str = this.splicer(str, obj.b, 1);
// 		str = this.splicer(str, obj.a, 1);
// 		str += letter;
// 		return str;
// 	},

// 	// Create array of all pairs, sorted by largest, left-most pairs
// 	createSorted: function (obj) {
// 		var pairs = []
// 			, all = [];
// 		for (i in obj) {
// 			pairs = this.createPairs(obj[i]);
// 			for (var j = 0; j < pairs.length; j++) {
// 				all.push(pairs[j]);
// 			}
// 		}
// 		return this.sortPairs(all);
// 	},

// 	// Return first valid pair of characters from sorted array
// 	getFirstValid: function (arr) {
// 		var point = {};
// 		for (var k = 0; k < arr.length; k++) {
// 			point = this.checkValid(arr[k][1], arr[k][0], string);
// 			if (point) {
// 				return point;
// 			}
// 		}
// 	},

// 	// Create new array with all possible character index pairs as separate arrays
// 	// Example: [1,4,9] -> [[9,4],[9,1],[4,1]]
// 	createPairs: function (arr) {
// 		var pairs = [];
// 		for (var i = arr.length-1; i > 0; i--) {
// 			if (i === 1) {
// 				pairs.push([arr[i],arr[0]]);
// 			} else {
// 				for (var j = i-1; j > i-3; j--) {
// 					pairs.push([arr[i],arr[j]]);
// 				}
// 			}
// 		}
// 		return pairs;
// 	},

// 	// Sort character index pairs so that largest, left-most gaps occur first
// 	// Example: [[9,4],[9,1],[4,1]] -> [[9,1],[9,4],[4,1]]
// 	sortPairs: function (arr) {
// 		arr.sort(function (a, b) {
// 			var diff = (b[0]-b[1]) - (a[0]-a[1]);
// 			if (diff === 0) {
// 				return a[1] - b[1];
// 			} else {
// 				return diff;
// 			}
// 		});
// 		return arr;
// 	},

// 	// Return an object with start, end and distance properties for valid pairs
// 	// Example: If no repeated chars are found between [9,1], object {a: 1, b: 9, distance: 8} is returned
// 	checkValid: function (a, b) {
// 		var positions = []
// 		  , position = {};
// 		if (this.pairCheck(a, b)) {
// 			position = {
// 				a: a,
// 				b: b,
// 				distance: b - a
// 			};
// 			return position;
// 		}
// 		return false;
// 	},

// 	// Check for repeated characters in the substring between a pair of character indexes
// 	pairCheck: function (a, b) {
// 		var between = string.substr(a+1, b-a-1);
// 		if (this.findRepeated(between)) {
// 			return false;
// 		} else {
// 			return true;
// 		}
// 	},

// 	// Return true for the first repeated character found in a string
// 	findRepeated: function (str) {
// 		var uniques  = [];
// 		for (var i = 0; i < str.length; i++) {
// 			if (uniques.indexOf(str[i]) >= 0) {
// 				return true;
// 			} else {
// 				uniques.push(str[i]);
// 			}
// 		}
// 		return false;
// 	},

// 	// Array.splice functionality for strings
// 	splicer: function (str, pos, num) {
// 		return str.slice(0,pos) + (str.slice(pos+num))
// 	},

// 	// Remove underscore and all characters following it
// 	strip: function (str) {
// 		var underscore = str.indexOf('_');
// 		return str.substr(0, underscore);
// 	}

// };

// new Parser(string);

function Parser(string) {

	this.parse = function () {
		var pairsPresent = this.check(this.storeMultiples())
		  , largest = {};
		console.time('Parsed in');
		while (pairsPresent) {
			largest = this.getFirstValid(this.createSorted(this.storeMultiples()));
			string = this.change(largest);
			console.log(string);
			pairsPresent = this.check(this.storeMultiples());
		}
		string = this.strip(string);
		console.timeEnd('Parsed in');
		console.log(string);
	}

	// Return an object of characters as properties and their index values as array values
	// Example: For string, 'hello', return object {'h': [0], 'e': [1], 'l': [2,3], 'o': [4]}
	this.storeMultiples = function () {
		var str = string
		  , hash = {};
		for (i = 0; i < str.length; i++) {
			if (hash[str[i]]) {
				hash[str[i]].push(i);
			} else {
				hash[str[i]] = [i];
			}
		}
		return hash;
	}

	// Return true for the first property value array that contains multiple values
	this.check = function (obj) {
		for (i in obj) {
			if (obj[i].length > 1) {
				return true;
			}
		}
	}

	// Return string after removing the character pair and adding a copy of the character to the end
	this.change = function (obj) {
		var str = string
		  , letter = str[obj.b];
		str = this.splicer(str, obj.b, 1);
		str = this.splicer(str, obj.a, 1);
		str += letter;
		return str;
	}

	// Create array of all pairs, sorted by largest, left-most pairs
	this.createSorted = function (obj) {
		var pairs = []
			, all = [];
		for (i in obj) {
			pairs = this.createPairs(obj[i]);
			for (var j = 0; j < pairs.length; j++) {
				all.push(pairs[j]);
			}
		}
		return this.sortPairs(all);
	}

	// Return first valid pair of characters from sorted array
	this.getFirstValid = function (arr) {
		var point = {};
		for (var k = 0; k < arr.length; k++) {
			point = this.checkValid(arr[k][1], arr[k][0], string);
			if (point) {
				return point;
			}
		}
	}

	// Create new array with all possible character index pairs as separate arrays
	// Example: [1,4,9] -> [[9,4],[9,1],[4,1]]
	this.createPairs = function (arr) {
		var pairs = [];
		for (var i = arr.length-1; i > 0; i--) {
			if (i === 1) {
				pairs.push([arr[i],arr[0]]);
			} else {
				for (var j = i-1; j > i-3; j--) {
					pairs.push([arr[i],arr[j]]);
				}
			}
		}
		return pairs;
	}

	// Sort character index pairs so that largest, left-most gaps occur first
	// Example: [[9,4],[9,1],[4,1]] -> [[9,1],[9,4],[4,1]]
	this.sortPairs = function (arr) {
		arr.sort(function (a, b) {
			var diff = (b[0]-b[1]) - (a[0]-a[1]);
			if (diff === 0) {
				return a[1] - b[1];
			} else {
				return diff;
			}
		});
		return arr;
	}

	// Return an object with start, end and distance properties for valid pairs
	// Example: If no repeated chars are found between [9,1], object {a: 1, b: 9, distance: 8} is returned
	this.checkValid = function (a, b) {
		var positions = []
		  , position = {};
		if (this.pairCheck(a, b)) {
			position = {
				a: a,
				b: b,
				distance: b - a
			};
			return position;
		}
		return false;
	}

	// Check for repeated characters in the substring between a pair of character indexes
	this.pairCheck = function (a, b) {
		var between = string.substr(a+1, b-a-1);
		if (this.findRepeated(between)) {
			return false;
		} else {
			return true;
		}
	}

	// Return true for the first repeated character found in a string
	this.findRepeated = function (str) {
		var uniques  = [];
		for (var i = 0; i < str.length; i++) {
			if (uniques.indexOf(str[i]) >= 0) {
				return true;
			} else {
				uniques.push(str[i]);
			}
		}
		return false;
	}

	// Array.splice functionality for strings
	this.splicer = function (str, pos, num) {
		return str.slice(0,pos) + (str.slice(pos+num))
	}

	// Remove underscore and all characters following it
	this.strip = function (str) {
		var underscore = str.indexOf('_');
		return str.substr(0, underscore);
	}

}

new Parser(string).parse();